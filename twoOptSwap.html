<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>2-opt Swap Heuristik p5.js-Seite mit Slider</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
</head>
<body>
<script>
    let cities = [];
    let totalCities;
    let bestEver = [];
    let shortestDistance;
    let speedSlider;
    let isOptimizing = false;
    let i = 1;
    let k = 2;
    let progressP;
    let optimizationsDone = 0;

    function setup() {
        createCanvas(800, 600);
        initializeCities(100); // Standardwert für totalCities

        speedSlider = createSlider(1, 60, 30, 1);
        speedSlider.position(10, height + 25);

        totalCitiesInput = createInput('100');
        totalCitiesInput.position(10, height + 55);

        const updateButton = createButton('Städte aktualisieren');
        updateButton.position(150, height + 55);
        updateButton.mousePressed(() => {
            initializeCities(parseInt(totalCitiesInput.value()));
        });

        progressP = createP('Durchgeführte Optimierungen: ');
        progressP.position(10, height + 85);
    }

    function initializeCities(numCities) {
        cities = [];
        // Lege einen Abstand fest, der immer eingehalten wird zum Rand des Canvas (für eine schönere Ansicht)
        let padding = 20;

        for (let i = 0; i < numCities; i++) {
            const v = createVector(random(padding, width - padding), random(padding, height - padding));
            cities[i] = v;
        }
        bestEver = cities.slice();
        shortestDistance = calcDistance(cities);
        isOptimizing = false;
        i = 1;
        k = 2;
        optimizationsDone = 0;
        loop();
    }

    function draw() {
        background(0);

        if (!isOptimizing) {
            isOptimizing = true;
            setTimeout(() => {
                [isOptimizing, i, k] = optimizeRoute(bestEver, i, k);
                optimizationsDone++;
                let doneOptimizations = optimizationsDone;
                progressP.html(`Durchgeführte Optimierungen: ${doneOptimizations}`);
            }, 1000 / speedSlider.value());
        }

        drawTour(bestEver, color(255, 20, 147), 2);
        stroke(255);
        fill(255);
        cities.forEach(city => ellipse(city.x, city.y, 8, 8));
    }

    function drawTour(tour, strokeC, strokeW) {
        stroke(strokeC);
        strokeWeight(strokeW);
        noFill();
        beginShape();
        for (let i = 0; i < tour.length; i++) {
            vertex(tour[i].x, tour[i].y);
        }
        endShape(CLOSE);
    }

    function calcDistance(points) {
        let sum = 0;
        for (let i = 0; i < points.length - 1; i++) {
            sum += dist(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y);
        }
        sum += dist(points[points.length - 1].x, points[0].y, points[0].x, points[points.length - 1].y);
        return sum;
    }

    function optimizeRoute(route, i, k) {
        if (i < route.length - 1) {
            for (let k = i + 1; k < route.length; k++) {
                let newRoute = twoOptSwap(route, i, k);
                let newDistance = calcDistance(newRoute);
                if (newDistance < shortestDistance) {
                    bestEver = newRoute.slice();
                    shortestDistance = newDistance;
                    return [false, i, k + 1];
                }
            }
            return [false, i + 1, i + 2];
        } else {
            noLoop(); // Optimization finished
            console.log('Optimization completed');
            return [false, 1, 2];
        }
    }

    function twoOptSwap(route, i, k) {
        let newRoute = route.slice(0, i);
        let reversedSegment = route.slice(i, k + 1).reverse();
        let remainingRoute = route.slice(k + 1);
        newRoute.push(...reversedSegment, ...remainingRoute);
        return newRoute;
    }
</script>
</body>
</html>
