<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Travelling Salesman Problem Visualisierung - Two-Opt</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
</head>
<body>
<label for="tspSelect"></label><select id="tspSelect">
    <option value="" disabled selected>Wähle eine TSP Datei</option>
    <option value="ulysses16.tsp">Ulysses 16</option>
    <option value="bier127.tsp">Bier 127</option>
    <option value="a280.tsp">A 280</option>
    <option value="rl1304.tsp">RL 1304</option>
</select>

<div id="tourLength">Tour Länge: N/A</div>
<div id="swapCount">Anzahl der Swaps: 0</div>
<label for="stepByStep">Schritt-für-Schritt-Visualisierung:</label>
<input type="checkbox" id="stepByStep">
<button id="startButton">Optimierung starten</button>


<script>
    let cities = [];
    let bestEver = [];
    let swapCounter = 0;
    let xMin, xMax, yMin, yMax;
    let i = 1, k = 2, improved = false;
    let tourLength = 0;
    let showStepByStep = false;
    let optimizationStarted = false;


    const filePaths = {
        'ulysses16.tsp': 'TSPData/ulysses16.tsp',
        'bier127.tsp': 'TSPData/bier127.tsp',
        'a280.tsp': 'TSPData/a280.tsp',
        'rl1304.tsp': 'TSPData/rl1304.tsp'
    };

    document.getElementById('tspSelect').addEventListener('change', handleSelectChange);
    document.getElementById('startButton').addEventListener('click', startOptimization);


    function handleSelectChange(event) {
        const selectedFile = event.target.value;
        const filePath = filePaths[selectedFile];
        loadTSPFile(filePath);

        const stepByStepChecked = document.getElementById('stepByStep').checked;

        // Set showStepByStep based on selected file
        // Because for big Instances this should not be displayed as it takes a longer time to visualize this process.
        // Just the end Tour is fine here.
        if (selectedFile === 'ulysses16.tsp' && stepByStepChecked) {
            showStepByStep = true;
        } else if (selectedFile === 'bier127.tsp' && stepByStepChecked) {
            showStepByStep = true;
        } else {
            showStepByStep = false;
        }

        optimizationStarted = false;
        noLoop(); // Stop the loop until the button is clicked
    }

    function startOptimization() {
        if (showStepByStep) {
            optimizationStarted = true;
            frameRate(60);
            loop();
        } else {
            performComplete2Opt();
            draw();
        }
    }


    function loadTSPFile(filepath) {
        fetch(filepath)
            .then(response => response.text())
            .then(data => {
                loadCities(data);
                noLoop();
                draw();
                //loop();
            });
    }

    function loadCities(data) {
        let lines = data.trim().split('\n');
        let coordSection = false;
        cities = [];
        for (let line of lines) {
            line = line.trim();
            if (line === 'NODE_COORD_SECTION') {
                coordSection = true;
                continue;
            }
            if (line === 'EOF' || line === '' || !coordSection) {
                coordSection = false;
                continue;
            }
            let parts = line.split(/\s+/);
            let v = createVector(parseFloat(parts[1]), parseFloat(parts[2]));
            cities.push(v);
        }
        bestEver = cities.slice();
        i = 1;
        k = 2;
        improved = false;
        swapCounter = 0;
        calculateBounds();
    }

    function calculateBounds() {
        if (cities.length > 0){
            xMin = Math.min(...cities.map(city => city.x));
            xMax = Math.max(...cities.map(city => city.x));
            yMin = Math.min(...cities.map(city => city.y));
            yMax = Math.max(...cities.map(city => city.y));
        }else {
            console.error("No cities loaded!");
        }
    }

    function setup() {
        createCanvas(1200, 800);
        background(255);
        noLoop();
    }

    function draw() {
        background(255);
        //performStepByStep2Opt();

        if (optimizationStarted && showStepByStep) {
            performStepByStep2Opt();
        }

        bestEver.forEach(city => {
            let mappedX = map(city.x, xMin, xMax, 20, width - 20);
            let mappedY = map(city.y, yMin, yMax, 20, height - 20);
            fill(0);
            ellipse(mappedX, mappedY, 4, 4);
        });

        stroke(0);
        strokeWeight(2);
        noFill();
        beginShape();
        bestEver.forEach(city => {
            let mappedX = map(city.x, xMin, xMax, 20, width - 20);
            let mappedY = map(city.y, yMin, yMax, 20, height - 20);
            vertex(mappedX, mappedY);
        });
        endShape();

        // Draw final connection to close the tour
        if (bestEver.length > 1) {
            let firstCity = bestEver[0];
            let lastCity = bestEver[bestEver.length - 1];
            let mappedX1 = map(firstCity.x, xMin, xMax, 20, width - 20);
            let mappedY1 = map(firstCity.y, yMin, yMax, 20, height - 20);
            let mappedX2 = map(lastCity.x, xMin, xMax, 20, width - 20);
            let mappedY2 = map(lastCity.y, yMin, yMax, 20, height - 20);
            line(mappedX1, mappedY1, mappedX2, mappedY2);
        }

        tourLength = calculateTourLength(bestEver);
        document.getElementById('tourLength').innerText = `Tour Länge: ${tourLength.toFixed(2)}`;
    }

    function performStepByStep2Opt() {

        if (i < bestEver.length - 1) {
            // goes up the whole k scale until it reaches the length of the tour (to nodes in the problem)
            // then it enters the first else case and if improved is true, which it is, if a single swap with i being 1 und k switching through every entry in the array
            // then it sets i and k back to 1 and 2 and improved to false. and it does the same thing again.
            // So there could be a new improvement because things have changed, new edges are there and therefore the tour is new, so it could be that starting with the same indices
            // leeds to a new Tour that's actually better.
            // If not so, it enters the else case, and it increments the i for the first time and k is now i + 1 so starting at 3.
            // And so on and so forth until every edge is swapped around.
            if (k < bestEver.length) {
                let newTour = twoOptSwap(bestEver, i, k);
                if (calculateTourLength(newTour) < calculateTourLength(bestEver)) {
                    bestEver = newTour;
                    improved = true;
                    swapCounter++;
                    document.getElementById('swapCount').innerText = `Anzahl der Swaps: ${swapCounter}`;
                    tourLength = calculateTourLength(bestEver);
                    document.getElementById('tourLength').innerText = `Tour Länge: ${tourLength.toFixed(2)}`;
                }
                k++;
            } else {
                if (improved) {
                    improved = false;
                    i = 1;
                    k = 2;
                } else {
                    i++;
                    k = i + 1;
                }
            }
        }

        // if i reached to bestEver.length so the whole algorithm is finished, it once again calculates this final tour und stops the visualization
        // to show the final best found Tour until another command appears.
        if (i >= bestEver.length - 1) {
            tourLength = calculateTourLength(bestEver);
            document.getElementById('tourLength').innerText = `Tour Länge: ${tourLength.toFixed(2)}`;
            noLoop();
        }
    }


    function performComplete2Opt() {
        while (i < bestEver.length - 1) {
            if (k < bestEver.length) {
                let newTour = twoOptSwap(bestEver, i, k);
                if (calculateTourLength(newTour) < calculateTourLength(bestEver)) {
                    bestEver = newTour;
                    improved = true;
                    swapCounter++;
                    document.getElementById('swapCount').innerText = `Anzahl der Swaps: ${swapCounter}`;
                    tourLength = calculateTourLength(bestEver);
                    document.getElementById('tourLength').innerText = `Tour Länge: ${tourLength.toFixed(2)}`;
                }
                k++;
            } else {
                if (improved) {
                    improved = false;
                    i = 1;
                    k = 2;
                } else {
                    i++;
                    k = i + 1;
                }
            }
        }
        tourLength = calculateTourLength(bestEver);
        document.getElementById('tourLength').innerText = `Tour Länge: ${tourLength.toFixed(2)}`;
    }


    function twoOptSwap(tour, i, k) {
        let newTour = tour.slice(0, i).concat(tour.slice(i, k + 1).reverse()).concat(tour.slice(k + 1));
        return newTour;
    }

    function calculateTourLength(tour) {
        let totalDist = 0;
        for (let i = 0; i < tour.length - 1; i++) {
            totalDist += dist(tour[i].x, tour[i].y, tour[i + 1].x, tour[i + 1].y);
        }
        // Close the tour
        totalDist += dist(tour[tour.length - 1].x, tour[tour.length - 1].y, tour[0].x, tour[0].y);
        return totalDist;
    }

</script>
</body>
</html>