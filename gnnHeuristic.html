<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Travelling Salesman Problem Visualisierung - GNN</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet"> <!-- Überprüfen ob Bootstrap korrekt eingebunden ist -->
    <style>
        body {
            padding: 20px;
        }
        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 300px;
            margin-right: 20px;
        }
        #canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #canvas-holder {
            width: 1000px;
            height: 800px;
        }
    </style>
</head>
<body>
<div class="container-fluid">
    <h1>TSP Visualisierung - Greedy Nearest Neighbor</h1>
    <div class="row">
        <div class="col-12 col-md-2">
            <div id="controls" class="form-group">
                <label for="tspSelect">Wähle eine TSP Datei:</label>
                <select id="tspSelect" class="form-control">
                    <option value="" disabled selected>Wähle eine TSP Datei</option>
                    <option value="ulysses16.tsp">Ulysses 16</option>
                    <option value="berlin52.tsp">Berlin 52</option>
                    <option value="bier127.tsp">Bier 127</option>
                    <option value="a280.tsp">A 280</option>
                    <option value="rl1304.tsp">RL 1304</option>
                </select>

                <div id="info" class="mt-3">
                    <div id="tourLength">Tour Länge: N/A</div>
                </div>
                <button id="startButton" class="btn btn-primary mt-3">Animation Starten</button>
            </div>
        </div>
        <div class="col-12 col-md-10" id="canvas-container">
            <div id="canvas-holder">
                <script>
                    function setup() {
                        let canvas = createCanvas(1200, 800);
                        canvas.parent('canvas-holder');
                        background(255);
                        noLoop();
                    }
                </script>
            </div>
        </div>
    </div>
</div>

<script>
    let cities = [];
    let bestEver = [];
    let unvisitedCities = [];
    let citiesVisited = 0;
    let frameCounter = 0;
    let xMin, xMax, yMin, yMax;
    const filePaths = {
        'ulysses16.tsp': 'TSPData/ulysses16.tsp',
        'berlin52.tsp': 'TSPData/berlin52.tsp',
        'bier127.tsp': 'TSPData/bier127.tsp',
        'a280.tsp': 'TSPData/a280.tsp',
        'rl1304.tsp': 'TSPData/rl1304.tsp'
    };

    document.getElementById('tspSelect').addEventListener('change', handleSelectChange);
    document.getElementById('startButton').addEventListener('click', startAnimation);

    function handleSelectChange(event) {
        const selectedFile = event.target.value;
        const filePath = filePaths[selectedFile];
        loadTSPFile(filePath);
    }

    function loadTSPFile(filepath) {
        fetch(filepath)
            .then(response => response.text())
            .then(data => {
                loadCities(data);
                setupSketch();
            });
    }

    function loadCities(data) {
        let lines = data.trim().split('\n');
        let coordSection = false;
        cities = [];
        unvisitedCities = [];
        for (let line of lines) {
            line = line.trim();
            if (line === 'NODE_COORD_SECTION') {
                coordSection = true;
                continue;
            }
            if (line === 'EOF' || line === '' || !coordSection) {
                coordSection = false;
                continue;
            }
            let parts = line.split(/\s+/);
            let v = createVector(parseFloat(parts[1]), parseFloat(parts[2]));
            cities.push(v);
            unvisitedCities.push(v);
        }
        bestEver = [cities[0]];
        unvisitedCities.splice(0, 1);  // Remove the first city from the unvisited list
        citiesVisited = 0;
        calculateBounds();
    }

    function calculateBounds() {
        xMin = Math.min(...cities.map(city => city.x));
        xMax = Math.max(...cities.map(city => city.x));
        yMin = Math.min(...cities.map(city => city.y));
        yMax = Math.max(...cities.map(city => city.y));
    }

    function setupSketch() {
        let canvas = createCanvas(1000, 800);
        canvas.parent('canvas-holder');
        background(255);
        drawCities();
        noLoop();
    }

    function startAnimation() {
        loop();
    }

    function setup() {
        // Initial setup to create canvas, called once
        noLoop();  // No looping until file is loaded and animation is started
    }

    function draw() {
        background(255);
        drawCities();

        if (unvisitedCities.length > 0 && frameCounter >= 10) {
            findAndDrawNextClosestCity();
            frameCounter = 0;
        } else {
            frameCounter++;
        }

        if (unvisitedCities.length === 0) {
            drawFinalConnection();
            let tourLength = calculateTourLength(bestEver);
            document.getElementById('tourLength').innerText = `Tour Länge: ${tourLength.toFixed(2)}`;
            noLoop();
        } else {
            let tourLength = calculateTourLength(bestEver);
            document.getElementById('tourLength').innerText = `Tour Länge: ${tourLength.toFixed(2)}`;
        }

        stroke(0);
        strokeWeight(2);
        noFill();
        beginShape();
        bestEver.forEach(city => {
            let mappedX = map(city.x, xMin, xMax, 20, width - 20);
            let mappedY = map(city.y, yMin, yMax, 20, height - 20);
            vertex(mappedX, mappedY);
        });
        endShape();
    }

    function drawCities() {
        fill(0);
        cities.forEach(city => {
            let mappedX = map(city.x, xMin, xMax, 20, width - 20);
            let mappedY = map(city.y, yMin, yMax, 20, height - 20);
            ellipse(mappedX, mappedY, 4, 4);
        });

        bestEver.forEach(city => {
            let mappedX = map(city.x, xMin, xMax, 20, width - 20);
            let mappedY = map(city.y, yMin, yMax, 20, height - 20);
            fill(0);
            ellipse(mappedX, mappedY, 4, 4);
        });
    }

    function findAndDrawNextClosestCity() {
        let lastCity = bestEver[bestEver.length - 1];
        let recordDistance = Infinity;
        let closestCityIndex = -1;

        for (let i = 0; i < unvisitedCities.length; i++) {
            let d = dist(lastCity.x, lastCity.y, unvisitedCities[i].x, unvisitedCities[i].y);
            if (d < recordDistance) {
                recordDistance = d;
                closestCityIndex = i;
            }
        }

        if (closestCityIndex >= 0) {
            bestEver.push(unvisitedCities[closestCityIndex]);
            unvisitedCities.splice(closestCityIndex, 1);
            citiesVisited++;
        }
    }

    function drawFinalConnection() {
        stroke(0);
        strokeWeight(2);
        let firstCity = bestEver[0];
        let lastCity = bestEver[bestEver.length - 1];
        let mappedX1 = map(firstCity.x, xMin, xMax, 20, width - 20);
        let mappedY1 = map(firstCity.y, yMin, yMax, 20, height - 20);
        let mappedX2 = map(lastCity.x, xMin, xMax, 20, width - 20);
        let mappedY2 = map(lastCity.y, yMin, yMax, 20, height - 20);
        line(mappedX1, mappedY1, mappedX2, mappedY2);
    }

    function calculateTourLength(tour) {
        let totalDist = 0;
        for (let i = 0; i < tour.length - 1; i++) {
            totalDist += dist(tour[i].x, tour[i].y, tour[i + 1].x, tour[i + 1].y);
        }
        totalDist += dist(tour[tour.length - 1].x, tour[tour.length - 1].y, tour[0].x, tour[0].y);
        return totalDist;
    }
</script>
</body>
</html>
