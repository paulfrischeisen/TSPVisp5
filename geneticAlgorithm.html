<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>TSP Visualisierung - Genetischer Algorithmus</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            padding: 20px;
        }
        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 300px;
            margin-right: 20px;
        }
        #canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #chart-container {
            width: 1000px;
            height: 600px;
        }
        #canvas-holder {
            width: 1000px;
            height: 800px;
        }
    </style>
</head>
<body>
<div class="container-fluid">
    <h1>TSP Visualisierung - Genetischer Algorithmus</h1>
    <div class="row">
        <div class="col-12 col-md-2">
            <div id="controls" class="form-group">
                <label for="tspSelect">Wähle eine TSP Datei:</label>
                <select id="tspSelect" class="form-control">
                    <option value="" disabled selected>Wähle eine TSP Datei</option>
                    <option value="ulysses16.tsp">Odyssey of Ulysses 16</option>
                    <option value="bayg29.tsp">Cities in Bavaria 29</option>
                    <option value="berlin52.tsp">Locations in Berlin 52</option>
                    <option value="st70.tsp">City Problem 70</option>
                    <option value="pr76.tsp">City Problem 76</option>
                    <option value="bier127.tsp">Biergärten Augsburg 127</option>
                    <option value="a280.tsp">Drilling Problem 280</option>
                </select>

                <label for="popSizeInput">Populationsgröße:</label>
                <input type="number" id="popSizeInput" class="form-control" value="100">

                <label for="mutationRateInput">Mutationsrate:</label>
                <input type="number" id="mutationRateInput" class="form-control" step="0.01" value="0.01">

                <label for="tournamentSizeInput">Größe der Tournament-Selection:</label>
                <input type="number" id="tournamentSizeInput" class="form-control" value="5">

                <label for="generationsInput">Anzahl der Generationen (wenn keine Schritt-für-Schritt Optimierung):</label>
                <input type="number" id="generationsInput" class="form-control" value="500">

                <div class="form-check">
                    <label for="stepByStep" class="form-check-label">Schritt-für-Schritt-Visualisierung:</label>
                    <input type="checkbox" id="stepByStep" class="form-check-input ml-2">
                </div>

                <button id="startButton" class="btn btn-primary mt-3">GA Optimierung starten</button>

                <div id="info" class="mt-3">
                    <div id="tourLength">Tour Länge: N/A</div>
                    <div id="generationCount">Anzahl der Generationen: 0</div>
                </div>
            </div>
        </div>
        <div class="col-12 col-md-6" id="canvas-container">
            <div id="canvas-holder">
                <script>
                    function setup() {
                        let canvas = createCanvas(1000, 800);
                        canvas.parent('canvas-holder');
                        background(255);
                        noLoop();
                    }
                </script>
            </div>
        </div>
        <div class="col-12 col-md-4" id="chart-container">
            <canvas id="tourLengthChart"></canvas>
        </div>
    </div>
</div>

<script>
    let cities = [];
    let bestEver = [];
    let population = [];
    let popSize = 100;
    let mutationRate = 0.01;
    let generations = 0;
    let tournamentSize = 5;
    let completeGenerations = 500;
    let xMin, xMax, yMin, yMax;
    let tourLength = 0;
    let showStepByStep = false;
    let optimizationStarted = false;
    let tourLengthData = [];
    let generationData = [];
    let tourLengthChart;

    const filePaths = {
        'ulysses16.tsp': 'TSPData/ulysses16.tsp',
        'bayg29.tsp': 'TSPData/bayg29.tsp',
        'berlin52.tsp': 'TSPData/berlin52.tsp',
        'st70.tsp': 'TSPData/st70.tsp',
        'pr76.tsp': 'TSPData/pr76.tsp',
        'bier127.tsp': 'TSPData/bier127.tsp',
        'a280.tsp': 'TSPData/a280.tsp',
    };

    document.getElementById('tspSelect').addEventListener('change', handleSelectChange);
    document.getElementById('startButton').addEventListener('click', startOptimization);
    document.getElementById('popSizeInput').addEventListener('change', updatePopSize);
    document.getElementById('mutationRateInput').addEventListener('change', updateMutationRate);
    document.getElementById('tournamentSizeInput').addEventListener('change', updateTournamentSize);
    document.getElementById('generationsInput').addEventListener('change', updateCompleteGenerations);

    function handleSelectChange(event) {
        const selectedFile = event.target.value;
        const filePath = filePaths[selectedFile];
        loadTSPFile(filePath);

        const stepByStepChecked = document.getElementById('stepByStep').checked;
        showStepByStep = stepByStepChecked;

        optimizationStarted = false;
        noLoop(); // Stop the loop until the button is clicked
    }

    function startOptimization() {
        if (showStepByStep) {
            optimizationStarted = true;
            frameRate(60);
            loop();
        } else {
            performCompleteGA();
            draw();
        }
    }

    function updatePopSize() {
        popSize = document.getElementById('popSizeInput').value;
    }

    function updateMutationRate() {
        mutationRate = document.getElementById('mutationRateInput').value;
    }

    function updateTournamentSize() {
        tournamentSize = document.getElementById('tournamentSizeInput').value;
    }

    function updateCompleteGenerations() {
        completeGenerations = document.getElementById('generationsInput').value;
    }

    function loadTSPFile(filepath) {
        fetch(filepath)
            .then(response => response.text())
            .then(data => {
                loadCities(data);
                noLoop();
                draw();
            });
    }

    function loadCities(data) {
        let lines = data.trim().split('\n');
        let coordSection = false;
        cities = [];
        for (let line of lines) {
            line = line.trim();
            if (line === 'NODE_COORD_SECTION') {
                coordSection = true;
                continue;
            }
            if (line === 'EOF' || line === '' || !coordSection) {
                coordSection = false;
                continue;
            }
            let parts = line.split(/\s+/);
            let v = createVector(parseFloat(parts[1]), parseFloat(parts[2]));
            cities.push(v);
        }
        initializeGA();
        calculateBounds();
    }

    function initializeGA() {
        population = [];
        for (let i = 0; i < popSize; i++) {
            let tour = shuffle(cities.slice());
            population.push(tour);
        }
        bestEver = population[0];
        generations = 0;
        tourLengthData = [];
        generationData = [];
        if (tourLengthChart) {
            tourLengthChart.destroy();
        }
        setupChart();
    }

    function calculateBounds() {
        if (cities.length > 0) {
            xMin = Math.min(...cities.map(city => city.x));
            xMax = Math.max(...cities.map(city => city.x));
            yMin = Math.min(...cities.map(city => city.y));
            yMax = Math.max(...cities.map(city => city.y));
        } else {
            console.error("No cities loaded!");
        }
    }

    function setupChart() {
        const ctx = document.getElementById('tourLengthChart').getContext('2d');
        tourLengthChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: generationData,
                datasets: [{
                    label: 'Tour Länge',
                    data: tourLengthData,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    fill: false
                }]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Generationen'
                        }
                    },
                    y: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Tour Länge'
                        }
                    }
                }
            }
        });
    }

    function updateChart() {
        tourLengthData.push(tourLength);
        generationData.push(generations);
        tourLengthChart.update();
    }

    function draw() {
        background(255);

        if (optimizationStarted && showStepByStep) {
            performStepByStepGA();
        }

        bestEver.forEach(city => {
            let mappedX = map(city.x, xMin, xMax, 20, width - 20);
            let mappedY = map(city.y, yMin, yMax, 20, height - 20);
            fill(0);
            ellipse(mappedX, mappedY, 4, 4);
        });

        stroke(0);
        strokeWeight(2);
        noFill();
        beginShape();
        bestEver.forEach(city => {
            let mappedX = map(city.x, xMin, xMax, 20, width - 20);
            let mappedY = map(city.y, yMin, yMax, 20, height - 20);
            vertex(mappedX, mappedY);
        });
        endShape();

        // Draw final connection to close the tour
        if (bestEver.length > 1) {
            let firstCity = bestEver[0];
            let lastCity = bestEver[bestEver.length - 1];
            let mappedX1 = map(firstCity.x, xMin, xMax, 20, width - 20);
            let mappedY1 = map(firstCity.y, yMin, yMax, 20, height - 20);
            let mappedX2 = map(lastCity.x, xMin, xMax, 20, width - 20);
            let mappedY2 = map(lastCity.y, yMin, yMax, 20, height - 20);
            line(mappedX1, mappedY1, mappedX2, mappedY2);
        }

        tourLength = calculateTourLength(bestEver);
        document.getElementById('tourLength').innerText = `Tour Länge: ${tourLength.toFixed(2)}`;
        document.getElementById('generationCount').innerText = `Anzahl der Generationen: ${generations}`;

        updateChart();
    }

    function performStepByStepGA() {
        nextGeneration();
    }

    function performCompleteGA() {
        for (let i = 0; i < completeGenerations; i++) {
            nextGeneration();
        }
    }

    function nextGeneration() {
        let newPopulation = [];
        for (let i = 0; i < population.length; i++) {
            let parentA = selectParent();
            let parentB = selectParent();
            let child = crossover(parentA, parentB);
            mutate(child);
            newPopulation.push(child);
        }
        population = newPopulation;
        evaluatePopulation();
        generations++;
    }

    function selectParent() {
        // Tournament selection
        let best = null;
        for (let i = 0; i < tournamentSize; i++) {
            let ind = floor(random(population.length));
            let candidate = population[ind];
            if (best === null || calculateTourLength(candidate) < calculateTourLength(best)) {
                best = candidate;
            }
        }
        return best;
    }

    function crossover(parentA, parentB) {
        let start = floor(random(parentA.length));
        let end = floor(random(start + 1, parentA.length));
        let child = parentA.slice(start, end);

        for (let i = 0; i < parentB.length; i++) {
            let city = parentB[i];
            if (!child.includes(city)) {
                child.push(city);
            }
        }
        return child;
    }

    function mutate(tour) {
        for (let i = 0; i < tour.length; i++) {
            if (random(1) < mutationRate) {
                let j = floor(random(tour.length));
                [tour[i], tour[j]] = [tour[j], tour[i]];
            }
        }
    }

    function evaluatePopulation() {
        for (let i = 0; i < population.length; i++) {
            let tour = population[i];
            let d = calculateTourLength(tour);
            if (d < calculateTourLength(bestEver)) {
                bestEver = tour;
            }
        }
    }

    function calculateTourLength(tour) {
        let totalDist = 0;
        for (let i = 0; i < tour.length - 1; i++) {
            totalDist += dist(tour[i].x, tour[i].y, tour[i + 1].x, tour[i + 1].y);
        }
        totalDist += dist(tour[tour.length - 1].x, tour[tour.length - 1].y, tour[0].x, tour[0].y);
        return totalDist;
    }

</script>
</body>
</html>
